<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Balanced BST (A–O) — Precise Lines</title>
<style>
  :root{
    --bg:#0f172a;        /* slate-900 */
    --panel:#111827;     /* gray-900 */
    --node:#1f2937;      /* gray-800 */
    --node-text:#e5e7eb; /* gray-200 */
    --edge:#64748b;      /* slate-500 */
    --accent:#fbbf24;    /* amber-400 */
  }

  body{
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;
    background:linear-gradient(160deg,var(--bg),#111827 60%);
    color:#e5e7eb;
    min-height:100vh;
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:18px;
    padding:24px 16px 40px;
  }

  h1{font-weight:700; letter-spacing:.2px; margin:0}
  .controls{
    display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    background:rgba(17,24,39,.6);
    border:1px solid rgba(255,255,255,.06);
    padding:12px 14px; border-radius:14px; backdrop-filter: blur(6px);
  }
  .controls input{
    padding:10px 12px; border-radius:10px; border:1px solid #374151;
    background:#0b1220; color:#e5e7eb; width:160px; font-size:16px;
  }
  .controls button{
    padding:10px 14px; border-radius:10px; border:0; cursor:pointer;
    background:#2563eb; color:white; font-weight:600;
  }
  .controls button:hover{filter:brightness(1.1)}

  /* Drawing area */
  .canvas{
    position:relative;
    background:var(--panel);
    border:1px solid rgba(255,255,255,.07);
    border-radius:18px;
    box-shadow: 0 20px 60px rgba(0,0,0,.35) inset;
    overflow:hidden;
  }
  svg.edges{position:absolute; inset:0}

  /* Node styling (absolute, centered at its x/y) */
  .node{
    position:absolute;
    width:44px; height:44px; border-radius:999px;
    background:var(--node);
    color:var(--node-text);
    display:flex; align-items:center; justify-content:center;
    font-weight:800; letter-spacing:.5px;
    box-shadow: 0 2px 8px rgba(0,0,0,.4);
    transform: translate(-50%,-50%); /* position by center */
    transition: box-shadow .25s, background .25s, transform .15s;
  }
  .node.highlight{
    background:var(--accent);
    color:#111827;
    box-shadow: 0 0 22px rgba(251,191,36,.9), 0 8px 18px rgba(0,0,0,.45);
    transform: translate(-50%,-50%) scale(1.06);
  }

  /* Edge styling */
  .edge{
    stroke: var(--edge);
    stroke-width: 2.25;
    vector-effect: non-scaling-stroke; /* keep crisp on zoom */
  }
  .edge.highlight{
    stroke: var(--accent);
    stroke-width: 3;
    filter: drop-shadow(0 0 6px rgba(251,191,36,.9));
  }

  .legend{opacity:.8; font-size:.95rem}
</style>
</head>
<body>
  <h1>Balanced Binary Search Tree (A–O)</h1>
  <div class="controls">
    <input id="key" maxlength="1" placeholder="Enter A–O (e.g., K)" />
    <button id="btnSearch">Search</button>
    <button id="btnClear" style="background:#374151">Clear</button>
    <span class="legend">Lines are true parent→child diagonals (SVG)</span>
  </div>

  <div id="canvas" class="canvas"></div>

<script>
/* ---------- Data structures ---------- */
class Node{
  constructor(v){ this.v=v; this.left=null; this.right=null; this.x=0; this.y=0; }
}
function buildBalanced(sorted, lo, hi){
  if(lo>hi) return null;
  const mid = (lo+hi)>>1;
  const n = new Node(sorted[mid]);
  n.left  = buildBalanced(sorted, lo, mid-1);
  n.right = buildBalanced(sorted, mid+1, hi);
  return n;
}
const letters = "ABCDEFGHIJKLMNO".split("");
const root = buildBalanced(letters, 0, letters.length-1);

/* ---------- Layout: inorder x, depth y ---------- */
let col = 0, maxDepth = 0;
(function assign(node, depth=0){
  if(!node) return;
  assign(node.left, depth+1);
  node.x = col++; node.y = depth;
  if(depth>maxDepth) maxDepth=depth;
  assign(node.right, depth+1);
})(root);

/* Spacing/sizing */
const NODE = 44;
const XGAP = 90;         // horizontal distance between inorder columns
const YGAP = 90;         // vertical distance between levels
const MARGIN_X = 60, MARGIN_Y = 60;

const width  = MARGIN_X*2 + (col-1)*XGAP;
const height = MARGIN_Y*2 + maxDepth*YGAP;

/* ---------- Render nodes + edges with precise coordinates ---------- */
const canvas = document.getElementById("canvas");
canvas.style.width  = width + "px";
canvas.style.height = height + "px";

const svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
svg.setAttribute("class","edges");
svg.setAttribute("width", width);
svg.setAttribute("height", height);
canvas.appendChild(svg);

const nodeEls = new Map();
function cx(n){ return MARGIN_X + n.x*XGAP; }
function cy(n){ return MARGIN_Y + n.y*YGAP; }

function addNode(n){
  const el = document.createElement("div");
  el.className = "node";
  el.textContent = n.v;
  el.style.left = cx(n) + "px";
  el.style.top  = cy(n) + "px";
  el.id = "node-"+n.v;
  canvas.appendChild(el);
  nodeEls.set(n.v, el);
}
function addEdge(p,c){
  const line = document.createElementNS("http://www.w3.org/2000/svg","line");
  line.setAttribute("x1", cx(p));
  line.setAttribute("y1", cy(p));
  line.setAttribute("x2", cx(c));
  line.setAttribute("y2", cy(c));
  line.setAttribute("class","edge");
  line.id = "edge-"+p.v+"-"+c.v;
  svg.appendChild(line);
}

(function walk(n){
  if(!n) return;
  addNode(n);
  if(n.left){ addEdge(n,n.left); }
  if(n.right){ addEdge(n,n.right); }
  walk(n.left); walk(n.right);
})(root);

/* ---------- Search with path highlighting ---------- */
const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

function clearHighlights(){
  document.querySelectorAll(".node.highlight").forEach(e=>e.classList.remove("highlight"));
  document.querySelectorAll(".edge.highlight").forEach(e=>e.classList.remove("highlight"));
}

async function searchBST(target){
  target = (target||"").toUpperCase();
  if(!/^[A-O]$/.test(target)){ alert("Please enter a single letter from A–O"); return; }
  clearHighlights();

  let current = root;
  while(current){
    const nodeEl = nodeEls.get(current.v);
    nodeEl.classList.add("highlight");
    await sleep(650);

    if(current.v === target) return; // found; keep highlighted

    const goLeft = target < current.v;
    const next = goLeft ? current.left : current.right;
    if(!next) break;

    // highlight the exact edge we're taking
    const edgeId = "edge-"+current.v+"-"+next.v;
    const e = document.getElementById(edgeId);
    if(e){ e.classList.add("highlight"); }
    await sleep(250);

    current = next;
  }
  alert("Not found in A–O");
}

/* ---------- Controls ---------- */
document.getElementById("btnSearch").addEventListener("click", ()=>{
  searchBST(document.getElementById("key").value);
});
document.getElementById("btnClear").addEventListener("click", clearHighlights);
document.getElementById("key").addEventListener("keydown", (e)=>{
  if(e.key==="Enter") document.getElementById("btnSearch").click();
});
</script>
</body>
</html>
